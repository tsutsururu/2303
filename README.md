# 2303

# 223E  Σ[k=0..10^100]floor(X／10^k)

解答遷移 TLE WA TLE AC

計　52：48 + 15:00

➀ 思考

まず、10^(10^100) >> X より、X + X[:-1] + .... +X[0] が答え。素直にこれを求めても O(桁数) なので十分高速である。 今回は、Σ int(X[i] × (桁数-i)) でこれをオシャレに求めてみた。⇒ TLE / 四則演算は O(桁数) なので、これでは全体で O(桁数^2) となって全く間に合わない。⇒　i桁目は 桁の総和 - (i-1)桁目の数 の最終桁で求められる。つまり、繰り上がりを高速に求めることができれば、O(桁数) で間に合う。⇒ i 桁目が高々 6 桁であることに注目すると、各桁を管理するテーブルを作成し、該当位置を操作する処理で全桁を求められそうである。ただし最終的に答えをテーブルから復元する際、最初の理由で足し合わせることはできないので 文字列の結合で対処する。

➁ 解法

未決定値を保存しておき、各桁をこれに足し合わせてその最終桁をその桁の数とする。そして、2桁目以前を次に持ち越す。

③ 文字列の結合

X += T vs ""join() は計算量が異なる。前者は演算ごとに O(桁数) かかるので、全体で O( 桁数^2 ) かかるのに対して、後者は O(桁数) で済む。

参考：[Python Speed](https://sites.google.com/a/peignot.net/www/python-speed)

# 211  chokudai 2回目  diff 559

解答遷移 AC

計 10:11

➀ 思考

i 文字目を見て、例えば "o" だったら、i-1 文字目までで作成できる "ch" の個数だけ "cho" が作成できるので、dp[ 生成文字列の最後の文字 ] : 生成文字列の総数 で状態を定義すればよいと判断。一点更新なので、i 番目 の情報は与える必要はない。


# 0301

# 重複を許した DP

例えば、要素 S を重複を許して選んだ総和を M にする選び方の総数を求めることを考える。この時、dp[i][W] : i番目の要素までで総和 W を成す選び方の総数 とすると、普通であれば dp[i][W] += dp[i-1][W-S[i]]　で遷移を考えるだろう。しかし、これでは S[i] を一度選ぶような遷移しか考えることができない。そこで、dp[i][W] += dp[i][W-S[i]] とする。これによって、S[i] を既に選んだ場合も含めた状態からの遷移を考えることができるようになった。

![image](https://user-images.githubusercontent.com/109026838/222096719-75ca8d65-840d-4644-b507-86e3173eea61.png)


また、このように更新後の状態からの遷移のみを考えたいので、in-place 化することが可能。

# ☆  153E Crested Ibis vs Monster  diff 1015

降参

➀ 思考 

A/B 効率の貪欲法で解けそうだと思ったが、 (2,2),(6,4),(23,15) H=24 の場合無理。  ⇒　dp では O( Σ k/B × N = N×H^2 ) で無理だし、代案もなく降参 

➁ 思考

重複を許した dp で解く。

参考 : https://drken1215.hatenablog.com/entry/2020/01/26/225000

③ 感想

重複を許した dp を 手札に加えることができた。ナップサックを数か月ぶりに復習できた。次からは思いつける

# 178 Redistribution  2回目  diff 875

解答遷移 AC

➀ 思考

・dp

dp[i] = Σ dp[i-3] で遷移可能。更新後の情報が欲しいので in-place化

・メモ化

f(i) = Σ f(i-3) , f(0)=1 , f(1)=f(2)=0 で求められる。


# ☆ 099 Strange Bank  diff  1101

降参

➀ 解法

dp[i][M] : i番目まで使って、M円引き出すための最小回数　で状態を定義すると、**i番目のお金は重複を許して引き出せるので**、dp[i][M] = dp[i][M-m] +1 で遷移可能。したがって、N 以下の 6^i,9^i を順番で紐づけて、dp すればよい。in-place 化可能。

参考 : https://qiita.com/drken/items/ace3142967c4f01d42e9


# ☆ アルゴ式 特集 問題 7 

➀ 解法

各 A の重複数に制限のある 重複を許したdp である。したがって、dp[i][M] : 総数を M とするために選ぶ Ai の数 で状態を定義し、dp[i][M] =min(dp[i-1][M] , dp[i][M-A[1]] +1) と遷移する。更新後状態からの遷移を考えるので、in-place化可能。ただし個数制限は各要素で独立なので、Ai を変更するにあたって、既に選べる状態を 0 で初期化する必要がある。



# ☆ 197E  Traveler  diff 1379

初見：分け赤ランクなって降参　⇒ その後しばらく休憩とって時間かけて AC 

➀ 思考

同じ色のボールをすべてとり終わった位置を考える。これは右端か左端に限られる。なぜなら、途中でとり終わるとり方は必ず余計な道のりであり最適でないから。⇒ したがって、昇順に各端から各端へ進むことのみを考えた場合の最短距離を求めればよい。例えば、abs(新右端 - 旧右端) + abs(新左端 - 新右端)で 旧右端 → 新左端へ行く場合の距離を求められる。

➀' 初見

右端、左端で回収し終えることは理解できていたものの、旧右端 → 旧左端 → 新左端 → 新右端　のような遷移しかしないと考えたり、なぜか原点に戻ることを考えたりと、思い返すと意味不明な思考をしていた。
























